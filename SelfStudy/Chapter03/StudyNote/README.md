# Chapter 03. 演算子

* 演算子：与えられた変数やリテラルに対して、あらかじめ決められた処理を行うための記号  
* 非演算子：演算子によって処理される変数やリテラルのこと

## 3.1. 算術演算子
代数演算子ともいう。

| 演算子 | 概要 | 例 |
| --- | --- | --- |
| + | 加算 | 2 + 3 (= 5)
| - | 減算 | 3 - 2 (= 1)
| * | 乗算 | 2 * 3 (= 6)
| / | 除算 | 7 / 3 (= 2.33...)
| // | 除算 (切り捨て) | 7 // 3 (= 2)
| % | 剰余 (割った余り) | 10 % 3 (= 1)

---

### データ型によって挙動は変化する

文字列同士の「+」演算は、加算ではなく **連結** とみなす。

alg_op01.py
```
print('10' + '3')

print('こんにちは' + '赤ちゃん')
```

実行結果
```
$ python3 alg_op01.py

103
こんにちは赤ちゃん
```

「*」演算もできる。  
「文字列 * n」=「文字列を n 回繰り返した文字列」

alg_op02.py
```
print('こんにちは' * 3)
```

実行結果
```
$ python3 alg_op02.py 

こんにちはこんにちはこんにちは
```

→ <ins>演算子の役割はオペランドのデータ型によって変化する

---
### 文字列と数値との演算

<ins>Python では数値と文字列の組み合わせはできない。

alg_op_error01.py
```
print(15 + '30')
```

実行結果
```
$ python3 alg_op_error01.py 

Traceback (most recent call last):
  File "/Users/seinay/VSCode/GitHub/PythonStudy/SelfStudy/Chapter03/StudyNote/alg_op_error01.py", line 1, in <module>
    print(15 + '30')
          ~~~^~~~~~
TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

「int」や「str」などの関数で型を変換することで演算可能。

alg_op03.py
```
print(15 + int('30'))

print(str(15) + '30')
```

実行結果
```
$ python3 alg_op03.py 

45
1530
```

---
### 除算を表す演算子「/」「//」
* 「/」= 一般的な除算。int 同士の除算でも float になる可能性がある。
* 「//」= float 同士の除算でも整数を返す。

alg_op04.py
```
print(5 / 3)
print(5 // 3)
```

実行結果
```
$ python3 alg_op04.py 

1.6666666666666667
1
```

divmod  
整数部の商と剰余をまとめて表示できる

alg_op05.py
```
print(divmod(5,3))  # 5 / 3 して「1」が商で、「2」が余りになる。
```

実行結果
```
$ python3 alg_op05.py 

(1, 2)
```

---
### 浮動小数点数の演算には要注意
浮動小数点数を含んだ演算子の場合、想定とは違う結果が表示されることがある。  
Python が内部的に数値を 10 進数ではなく、2 進数で演算してしまっているから。  

alg_op06.py
```
print(0.2 * 3)

print(0.2 * 3 == 0.6)
```

実行結果
```
$ python3 alg_op06.py

0.6000000000000001
False
```

上記の問題を解決するには、 Decimal 型を使う必要がある。  
**Decimal 型**：10 進数の浮動小数点数をサポートする型。
* 「decimal.Decila(数値)」で生成できる
* int/float 型と同じく、「+」「-」「==」の演算子を利用できる
* Decimal の値は、文字列リテラルとして指定することが原則

alg_op07.py
```
import decimal

d1 = decimal.Decimal('0.2')
d2 = decimal.Decimal('3')
d3 = decimal.Decimal('0.6')

print(d1 * d2)
print(d1 * d2 == d3)
```

実行結果
```
$ python3 alg_op07.py

0.6
True
```

## 3.2. 代入演算子
左側で指定した変数に対して、右側の値を代入するるための演算子  
**複合代入演算子**：算術演算子やビット演算しなどを合わせた昨日のこと

| 演算子 | 概要 | 例 |
| --- | --- | --- |
| = | 変数などに値を代入 | x = 10 |
| += | 左辺と右辺を合算した結果を左辺に代入 | x = 5; x += 2 (x = 7) |
| -= | 左辺と右辺を減算した結果を左辺に代入 | x = 5; x -= 2 (x = 3) |
| *= | 左辺と右辺を乗算した結果を左辺に代入 | x = 5; x *= 2 (x = 10) |
| /= | 左辺を右辺で除算した結果を左辺に代入 | x = 5; x /= 2 (x = 2.5) |
| //= | 左辺を右辺で除算した結果 (整数) を左辺に代入 | x = 5; x //= 2 (x = 2) |
| %= | 左辺を右辺で除算した余りを左辺に代入 | x = 5; x %= 2 (x = 1) ※ 整数までで割り算をするので余りが 1 になる |
| **= | 左辺を右辺でべき乗した結果を左辺に代入 | x = 5; x **= 2 (x = 25) |
| &= | 左辺と右辺をビット論理積した結果を左辺に代入 | x = 10; x &= 2 (x =2) |
| ^= | 左辺と右辺をビット排他論理和した結果を左辺に代入 | x = 10; x ^= 2 (x = 8) |
| \|= | 左辺と右辺をビット論理和した結果を左辺に代入 | x = 10; x \|= 2 (x = 10) |
| >>= | 左辺を右辺の値だけ右シフトした結果を左辺に代入 | x = 10; x >>= 2 (x = 2) |
| <<= | 左辺を右辺の値だけ左シフトした結果を左辺に代入 | x = 10; x <<= 2 (x = 40)

**ビット論理積**
* AND
* 2 進数で見た時に 2 つの値が「1」である時のみ「1」と表示する。
* 片方だけ「1」の場合は、「0」と表示する。
* 両方とも「0」の場合も、「0」と表示する。

10 &= 2
10 を 2 進数で表すと、「1010」。  
2 を 2 進数で表すと、「10」。  
両方の値を足した時、両方とも「1」である場合は「1」、片方でも「0」の場合は「0」とする。

0010  
1010

→ 0010 = 2

**ビット論理和**
* OR
* 2 進数で見た時に 片方でも「1」である時、「1」と表示する。
* 両方とも「0」である時は「0」

0010  
1010

→ 1010 = 10

**ビット排他論理和**
* 2 進数で見た時に 2 つの値が「1」または「0」である時、「1」と表示する。
* 両方とも「0」だったり、「1」である時は「0」と表示する。

0010  
1010

→ 1000 = 8

**右シフト**  
「10」を 2 進数とした時、全ビットを右にずらす。

10 >>= 2  
1010 (00001010)  
0010 (00000010)

**左シフト**  
「10」を 2 進数とした時、全ビットを左にずらす。

10 <<= 2  
1010 (00001010)  
101000 (00101000)

---
### 数値のインクリメント/デクリメント　　
* インクリメント演算子：与えられたオペランドに対して 1 を加算すること
* デクリメント演算子：与えられたオペランドに対して 1 を減算すること
* ただし、「++」「--」演算子は <ins>Python には存在しない。
* その代わり、「+=」「-=」演算子を利用する。

inc_op01.py
```
# i++ ←→ i = i + 1
# i-- ←→ i = i - 1

i = 1

i += 1
print(i)

i -= 1
print(i)
```

実行結果
```
$ python3 inc_op01.py

2
1
```

5 ずつ増やす/減らすこともできる
```
i += 5
i -= 5
```

---
### 「=」演算子による代入は参照の引き渡し
* 参照/識別値：格納場所を表す情報のこと
* 変数には値の格納場所を表す情報を格納する。
* → 実際の値は、別の場所に格納されているということ。

ref_id.py
```
num1 = 10
num2 = num1

print(id(num1))
print(id(num2))
```

実行結果
```
$ python3 ref_id.py 

4309034152
4309034152
```

---
### ミュータブルとイミュータブル
* ミュータブル：変更可能な型。オブジェクトをそのまま中身だけを変更できる。
* イミュータブル：変更不可な型。一度作成したオブジェクトの中身を書き換えることはできない。値を変更するにはオブジェクトそのものを入れ替えなければならない。

assign01.py
```
# ミュータブル型
data1 = [1,2,3]
data2 = data1
data1[0] = 100

print(data1)
print(data2)

# イミュータブル型
x = 1
y = x
x += 10

print(x)
print(y)
```

実行結果
```
$ python3 assign01.py 

[100, 2, 3]
[100, 2, 3]
11
1
```

ミュータブルな型であっても、値そのものを差し替えた場合は異なるオブジェクトとなる。

assign02.py
```
data1 = [1,2,3]
data2 = data1
data1 = [4,5,6]  # 別のオブジェクトで置き換え

print(data1)
print(data2)
```

実行結果
```
$ python3 assign02.py 

[4, 5, 6]
[1, 2, 3]
```

---
### アンパック代入
リスト/辞書などを分解し、配下の要素を個々の変数に分解するための構文  
左辺に要素の数だけ変数を列挙する

右辺のリッストがここの要素に分解され、それぞれ対応する変数 a - e に代入される  

unpack01.py
```
data = [1,2,3,4,5]
a,b,c,d,e = data

print(a)
print(b)
print(c)
print(d)
print(e)
```

実行結果
```
$ python unpack01.py

1
2
3
4
5
```

上記の場合、左辺の変数と右辺 (リスト) の要素数は一致していなければいけない。  
以下の場合はエラーが出力される。

unpack_error01.py
```
data = [1,2,3,4,5]
a,b,c = data  # リスト要素が変数よりも多い
```

実行結果
```
$ python unpack_error01.py

Traceback (most recent call last):
  File "/Users/seinay/VSCode/GitHub/PythonStudy/SelfStudy/Chapter02/StudyNote/unpack_error01.py", line 2, in <module>
    a,b,c = data  # リスト要素が変数よりも多い
    ^^^^^
ValueError: too many values to unpack (expected 3)
```

unpack_error02.py
```
data = [1,2,3,4,5]
a,b,c,d,e,f = data  # リスト要素が変数よりも少ない
```

実行結果
```
$ python3 unpack_error02.py

Traceback (most recent call last):
  File "/Users/seinay/VSCode/GitHub/PythonStudy/SelfStudy/Chapter02/StudyNote/unpack_error02.py", line 2, in <module>
    a,b,c,d,e,f = data  # リスト要素が変数よりも少ない
    ^^^^^^^^^^^
ValueError: not enough values to unpack (expected 6, got 5)
```

---
### 残りの要素をまとめて代入する
変数に * を付与することで個々の変数に分解されなかった残りの要素をまとめてリストとして切り出すことができる

unpack02.py
```
data = [1,2,3,4,5]
m,n,*o = data

print(m)
print(n)
print(0)

r,*s,t = data

print(r)
print(s)
print(t)

*x,y,z, = data

print(x)
print(y)
print(z)
```

実行結果
```
$  python3 unpack02.py 

1
2
0
1
[2, 3, 4]
5
[1, 2, 3]
4
5
```

\* 付き変数で該当する要素がない時、空のリストが生成される

unpack03.py
```
data = [1,2]
a,b,*c = data

print(c)
```

実行結果
```
$ python3 unpack03.py 

[]
```

---
### 一部の要素を切り捨てる







## 3.3. 比較演算子

## 3.4. 論理演算子

## 3.5. ビット演算子

## 3.6. 演算子の優先順位と結合則